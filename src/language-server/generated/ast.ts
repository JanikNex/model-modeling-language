/******************************************************************************
 * This file was generated by langium-cli 1.1.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import { AstNode, AbstractAstReflection, Reference, ReferenceInfo, TypeMetaData } from 'langium';

export type AbstractElement = Class | Enum | Interface;

export const AbstractElement = 'AbstractElement';

export function isAbstractElement(item: unknown): item is AbstractElement {
    return reflection.isInstance(item, AbstractElement);
}

export type BoolVal = boolean;

export type DataType = 'bool' | 'double' | 'float' | 'int' | 'string';

export type Statement = Attribute | CReference;

export const Statement = 'Statement';

export function isStatement(item: unknown): item is Statement {
    return reflection.isInstance(item, Statement);
}

export interface Attribute extends AstNode {
    readonly $container: Class | Interface;
    readonly $type: 'Attribute';
    defaultValue?: BoolVal | number | string
    modifiers?: AttributeModifiers
    name: string
    type: DataType
}

export const Attribute = 'Attribute';

export function isAttribute(item: unknown): item is Attribute {
    return reflection.isInstance(item, Attribute);
}

export interface AttributeModifiers extends AstNode {
    readonly $container: Attribute;
    readonly $type: 'AttributeModifiers';
    derived: boolean
    id: boolean
    ordered: boolean
    readonly: boolean
    transient: boolean
    unique: boolean
    unsettable: boolean
    volatile: boolean
}

export const AttributeModifiers = 'AttributeModifiers';

export function isAttributeModifiers(item: unknown): item is AttributeModifiers {
    return reflection.isInstance(item, AttributeModifiers);
}

export interface Class extends AstNode {
    readonly $container: Package;
    readonly $type: 'Class';
    abstract: boolean
    body: Array<Statement>
    extendedClasses: Array<Reference<Class>>
    implementedInterfaces: Array<Reference<Interface>>
    name: string
}

export const Class = 'Class';

export function isClass(item: unknown): item is Class {
    return reflection.isInstance(item, Class);
}

export interface CReference extends AstNode {
    readonly $container: Class | Interface;
    readonly $type: 'CReference';
    modifiers?: ReferenceModifiers
    multiplicity: Multiplicity
    name: string
    opposite?: OppositeAnnotation
    type: Reference<Class>
}

export const CReference = 'CReference';

export function isCReference(item: unknown): item is CReference {
    return reflection.isInstance(item, CReference);
}

export interface Enum extends AstNode {
    readonly $container: Package;
    readonly $type: 'Enum' | 'EnumEntry';
    name: string
}

export const Enum = 'Enum';

export function isEnum(item: unknown): item is Enum {
    return reflection.isInstance(item, Enum);
}

export interface Import extends AstNode {
    readonly $container: Model;
    readonly $type: 'Import';
    aliases: Array<ImportAlias>
    target: string
}

export const Import = 'Import';

export function isImport(item: unknown): item is Import {
    return reflection.isInstance(item, Import);
}

export interface ImportAlias extends AstNode {
    readonly $container: Import;
    readonly $type: 'ImportAlias';
    alias: string
    name: string
}

export const ImportAlias = 'ImportAlias';

export function isImportAlias(item: unknown): item is ImportAlias {
    return reflection.isInstance(item, ImportAlias);
}

export interface Interface extends AstNode {
    readonly $container: Package;
    readonly $type: 'Interface';
    abstract: boolean
    body: Array<Statement>
    extendedInterfaces: Array<Reference<Interface>>
    name: string
}

export const Interface = 'Interface';

export function isInterface(item: unknown): item is Interface {
    return reflection.isInstance(item, Interface);
}

export interface Model extends AstNode {
    readonly $type: 'Model';
    imports: Array<Import>
    packages: Array<Package>
}

export const Model = 'Model';

export function isModel(item: unknown): item is Model {
    return reflection.isInstance(item, Model);
}

export interface Multiplicity extends AstNode {
    readonly $container: CReference;
    readonly $type: 'Multiplicity';
    mult?: number | string
    upperMult?: number | string
}

export const Multiplicity = 'Multiplicity';

export function isMultiplicity(item: unknown): item is Multiplicity {
    return reflection.isInstance(item, Multiplicity);
}

export interface OppositeAnnotation extends AstNode {
    readonly $container: CReference;
    readonly $type: 'OppositeAnnotation';
    reference: Reference<CReference>
}

export const OppositeAnnotation = 'OppositeAnnotation';

export function isOppositeAnnotation(item: unknown): item is OppositeAnnotation {
    return reflection.isInstance(item, OppositeAnnotation);
}

export interface Package extends AstNode {
    readonly $container: Model | Package;
    readonly $type: 'Package';
    body: Array<AbstractElement>
    name: string
    subPackages: Array<Package>
}

export const Package = 'Package';

export function isPackage(item: unknown): item is Package {
    return reflection.isInstance(item, Package);
}

export interface ReferenceModifiers extends AstNode {
    readonly $container: CReference;
    readonly $type: 'ReferenceModifiers';
    derived: boolean
    ordered: boolean
    readonly: boolean
    resolve: boolean
    transient: boolean
    unique: boolean
    unsettable: boolean
    volatile: boolean
}

export const ReferenceModifiers = 'ReferenceModifiers';

export function isReferenceModifiers(item: unknown): item is ReferenceModifiers {
    return reflection.isInstance(item, ReferenceModifiers);
}

export interface EnumEntry extends Enum {
    readonly $container: Package;
    readonly $type: 'EnumEntry';
    name: string
    value?: number | string
}

export const EnumEntry = 'EnumEntry';

export function isEnumEntry(item: unknown): item is EnumEntry {
    return reflection.isInstance(item, EnumEntry);
}

export interface ModelModelingLanguageAstType {
    AbstractElement: AbstractElement
    Attribute: Attribute
    AttributeModifiers: AttributeModifiers
    CReference: CReference
    Class: Class
    Enum: Enum
    EnumEntry: EnumEntry
    Import: Import
    ImportAlias: ImportAlias
    Interface: Interface
    Model: Model
    Multiplicity: Multiplicity
    OppositeAnnotation: OppositeAnnotation
    Package: Package
    ReferenceModifiers: ReferenceModifiers
    Statement: Statement
}

export class ModelModelingLanguageAstReflection extends AbstractAstReflection {

    getAllTypes(): string[] {
        return ['AbstractElement', 'Attribute', 'AttributeModifiers', 'CReference', 'Class', 'Enum', 'EnumEntry', 'Import', 'ImportAlias', 'Interface', 'Model', 'Multiplicity', 'OppositeAnnotation', 'Package', 'ReferenceModifiers', 'Statement'];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case Attribute:
            case CReference: {
                return this.isSubtype(Statement, supertype);
            }
            case Class:
            case Enum:
            case Interface: {
                return this.isSubtype(AbstractElement, supertype);
            }
            case EnumEntry: {
                return this.isSubtype(Enum, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'Class:extendedClasses':
            case 'CReference:type': {
                return Class;
            }
            case 'Class:implementedInterfaces':
            case 'Interface:extendedInterfaces': {
                return Interface;
            }
            case 'OppositeAnnotation:reference': {
                return CReference;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case 'AttributeModifiers': {
                return {
                    name: 'AttributeModifiers',
                    mandatory: [
                        { name: 'derived', type: 'boolean' },
                        { name: 'id', type: 'boolean' },
                        { name: 'ordered', type: 'boolean' },
                        { name: 'readonly', type: 'boolean' },
                        { name: 'transient', type: 'boolean' },
                        { name: 'unique', type: 'boolean' },
                        { name: 'unsettable', type: 'boolean' },
                        { name: 'volatile', type: 'boolean' }
                    ]
                };
            }
            case 'Class': {
                return {
                    name: 'Class',
                    mandatory: [
                        { name: 'abstract', type: 'boolean' },
                        { name: 'body', type: 'array' },
                        { name: 'extendedClasses', type: 'array' },
                        { name: 'implementedInterfaces', type: 'array' }
                    ]
                };
            }
            case 'Import': {
                return {
                    name: 'Import',
                    mandatory: [
                        { name: 'aliases', type: 'array' }
                    ]
                };
            }
            case 'Interface': {
                return {
                    name: 'Interface',
                    mandatory: [
                        { name: 'abstract', type: 'boolean' },
                        { name: 'body', type: 'array' },
                        { name: 'extendedInterfaces', type: 'array' }
                    ]
                };
            }
            case 'Model': {
                return {
                    name: 'Model',
                    mandatory: [
                        { name: 'imports', type: 'array' },
                        { name: 'packages', type: 'array' }
                    ]
                };
            }
            case 'Package': {
                return {
                    name: 'Package',
                    mandatory: [
                        { name: 'body', type: 'array' },
                        { name: 'subPackages', type: 'array' }
                    ]
                };
            }
            case 'ReferenceModifiers': {
                return {
                    name: 'ReferenceModifiers',
                    mandatory: [
                        { name: 'derived', type: 'boolean' },
                        { name: 'ordered', type: 'boolean' },
                        { name: 'readonly', type: 'boolean' },
                        { name: 'resolve', type: 'boolean' },
                        { name: 'transient', type: 'boolean' },
                        { name: 'unique', type: 'boolean' },
                        { name: 'unsettable', type: 'boolean' },
                        { name: 'volatile', type: 'boolean' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}

export const reflection = new ModelModelingLanguageAstReflection();
