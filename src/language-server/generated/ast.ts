/******************************************************************************
 * This file was generated by langium-cli 1.1.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import { AstNode, AbstractAstReflection, Reference, ReferenceInfo, TypeMetaData } from 'langium';

export type AbstractElement = Class | Enum | Interface;

export const AbstractElement = 'AbstractElement';

export function isAbstractElement(item: unknown): item is AbstractElement {
    return reflection.isInstance(item, AbstractElement);
}

export type ArithExpr = BinaryExpression | ValueExpr;

export const ArithExpr = 'ArithExpr';

export function isArithExpr(item: unknown): item is ArithExpr {
    return reflection.isInstance(item, ArithExpr);
}

export type DataType = 'bool' | 'double' | 'float' | 'int' | 'string';

export type FunctionStatement = FunctionAssignment | FunctionCall | FunctionLoop | FunctionMacroCall;

export const FunctionStatement = 'FunctionStatement';

export function isFunctionStatement(item: unknown): item is FunctionStatement {
    return reflection.isInstance(item, FunctionStatement);
}

export type InstanceStatement = FunctionAssignment | FunctionCall | FunctionMacroCall;

export const InstanceStatement = 'InstanceStatement';

export function isInstanceStatement(item: unknown): item is InstanceStatement {
    return reflection.isInstance(item, InstanceStatement);
}

export type MacroStatement = MacroAssignStatement | MacroAttributeStatement;

export const MacroStatement = 'MacroStatement';

export function isMacroStatement(item: unknown): item is MacroStatement {
    return reflection.isInstance(item, MacroStatement);
}

export type Statement = Attribute | CReference;

export const Statement = 'Statement';

export function isStatement(item: unknown): item is Statement {
    return reflection.isInstance(item, Statement);
}

export type ValueExpr = BoolExpr | NumberExpr | StringExpr;

export const ValueExpr = 'ValueExpr';

export function isValueExpr(item: unknown): item is ValueExpr {
    return reflection.isInstance(item, ValueExpr);
}

export interface Attribute extends AstNode {
    readonly $container: Class | Interface;
    readonly $type: 'Attribute';
    defaultValue?: ArithExpr
    modifiers?: AttributeModifiers
    name: string
    type: DataType
}

export const Attribute = 'Attribute';

export function isAttribute(item: unknown): item is Attribute {
    return reflection.isInstance(item, Attribute);
}

export interface AttributeModifiers extends AstNode {
    readonly $container: Attribute;
    readonly $type: 'AttributeModifiers';
    derived: boolean
    id: boolean
    ordered: boolean
    readonly: boolean
    transient: boolean
    unique: boolean
    unsettable: boolean
    volatile: boolean
}

export const AttributeModifiers = 'AttributeModifiers';

export function isAttributeModifiers(item: unknown): item is AttributeModifiers {
    return reflection.isInstance(item, AttributeModifiers);
}

export interface BinaryExpression extends AstNode {
    readonly $container: Attribute | BinaryExpression | EnumEntry | FunctionArgument | ImplicitlyTypedValue | MacroAttributeStatement;
    readonly $type: 'BinaryExpression';
    left: ArithExpr
    operator: '%' | '*' | '+' | '-' | '/' | '^'
    right: ArithExpr
}

export const BinaryExpression = 'BinaryExpression';

export function isBinaryExpression(item: unknown): item is BinaryExpression {
    return reflection.isInstance(item, BinaryExpression);
}

export interface BoolExpr extends AstNode {
    readonly $container: Attribute | BinaryExpression | EnumEntry | FunctionArgument | ImplicitlyTypedValue | MacroAttributeStatement;
    readonly $type: 'BoolExpr';
    value: boolean
}

export const BoolExpr = 'BoolExpr';

export function isBoolExpr(item: unknown): item is BoolExpr {
    return reflection.isInstance(item, BoolExpr);
}

export interface Class extends AstNode {
    readonly $container: Package;
    readonly $type: 'Class';
    abstract: boolean
    body: Array<Statement>
    extendedClasses: Array<Reference<Class>>
    implementedInterfaces: Array<Reference<Interface>>
    name: string
}

export const Class = 'Class';

export function isClass(item: unknown): item is Class {
    return reflection.isInstance(item, Class);
}

export interface CReference extends AstNode {
    readonly $container: Class | Interface;
    readonly $type: 'CReference';
    modifiers?: ReferenceModifiers
    multiplicity?: Multiplicity
    name: string
    opposite?: OppositeAnnotation
    type: Reference<Class>
}

export const CReference = 'CReference';

export function isCReference(item: unknown): item is CReference {
    return reflection.isInstance(item, CReference);
}

export interface Enum extends AstNode {
    readonly $container: Package;
    readonly $type: 'Enum';
    entries: Array<EnumEntry>
    name: string
}

export const Enum = 'Enum';

export function isEnum(item: unknown): item is Enum {
    return reflection.isInstance(item, Enum);
}

export interface EnumEntry extends AstNode {
    readonly $container: Enum;
    readonly $type: 'EnumEntry';
    name: string
    value?: ValueExpr
}

export const EnumEntry = 'EnumEntry';

export function isEnumEntry(item: unknown): item is EnumEntry {
    return reflection.isInstance(item, EnumEntry);
}

export interface FunctionArgument extends AstNode {
    readonly $container: FunctionCall | FunctionMacroCall;
    readonly $type: 'FunctionArgument';
    ref?: Reference<InstanceVariable>
    value?: ArithExpr
}

export const FunctionArgument = 'FunctionArgument';

export function isFunctionArgument(item: unknown): item is FunctionArgument {
    return reflection.isInstance(item, FunctionArgument);
}

export interface FunctionAssignment extends AstNode {
    readonly $container: FunctionAssignment | FunctionLoop | IFunction | IInstance | InstanceLoop;
    readonly $type: 'FunctionAssignment';
    call: FunctionCall | FunctionMacroCall
    select?: Reference<InstanceVariable>
    var: InstanceVariable
}

export const FunctionAssignment = 'FunctionAssignment';

export function isFunctionAssignment(item: unknown): item is FunctionAssignment {
    return reflection.isInstance(item, FunctionAssignment);
}

export interface FunctionCall extends AstNode {
    readonly $container: FunctionAssignment | FunctionLoop | IFunction | IInstance | InstanceLoop;
    readonly $type: 'FunctionCall';
    args: Array<FunctionArgument>
    func: Reference<IFunction>
}

export const FunctionCall = 'FunctionCall';

export function isFunctionCall(item: unknown): item is FunctionCall {
    return reflection.isInstance(item, FunctionCall);
}

export interface FunctionLoop extends AstNode {
    readonly $container: FunctionAssignment | FunctionLoop | IFunction | IInstance | InstanceLoop;
    readonly $type: 'FunctionLoop';
    lower: number
    statements: Array<FunctionStatement>
    upper: number
    var: InstanceVariable
}

export const FunctionLoop = 'FunctionLoop';

export function isFunctionLoop(item: unknown): item is FunctionLoop {
    return reflection.isInstance(item, FunctionLoop);
}

export interface FunctionMacroCall extends AstNode {
    readonly $container: FunctionAssignment | FunctionLoop | IFunction | IInstance | InstanceLoop;
    readonly $type: 'FunctionMacroCall';
    args: Array<FunctionArgument>
    macro: Reference<IMacro>
}

export const FunctionMacroCall = 'FunctionMacroCall';

export function isFunctionMacroCall(item: unknown): item is FunctionMacroCall {
    return reflection.isInstance(item, FunctionMacroCall);
}

export interface FunctionReturn extends AstNode {
    readonly $container: IFunction;
    readonly $type: 'FunctionReturn';
    val?: ImplicitlyTypedValue
    var?: Reference<InstanceVariable>
}

export const FunctionReturn = 'FunctionReturn';

export function isFunctionReturn(item: unknown): item is FunctionReturn {
    return reflection.isInstance(item, FunctionReturn);
}

export interface IFunction extends AstNode {
    readonly $container: Model;
    readonly $type: 'IFunction';
    dtype?: DataType
    name: string
    parameter: Array<InstanceVariable>
    returnsVar: boolean
    statements: Array<FunctionReturn> | Array<FunctionStatement>
    type?: Reference<Class>
}

export const IFunction = 'IFunction';

export function isIFunction(item: unknown): item is IFunction {
    return reflection.isInstance(item, IFunction);
}

export interface IInstance extends AstNode {
    readonly $container: Model;
    readonly $type: 'IInstance';
    name: string
    statements: Array<InstanceLoop | InstanceStatement>
}

export const IInstance = 'IInstance';

export function isIInstance(item: unknown): item is IInstance {
    return reflection.isInstance(item, IInstance);
}

export interface IMacro extends AstNode {
    readonly $container: Model;
    readonly $type: 'IMacro';
    instances: Array<MacroInstance>
    name: string
    parameter: Array<InstanceVariable>
}

export const IMacro = 'IMacro';

export function isIMacro(item: unknown): item is IMacro {
    return reflection.isInstance(item, IMacro);
}

export interface ImplicitlyTypedValue extends AstNode {
    readonly $container: FunctionReturn;
    readonly $type: 'ImplicitlyTypedValue';
    val: ArithExpr
}

export const ImplicitlyTypedValue = 'ImplicitlyTypedValue';

export function isImplicitlyTypedValue(item: unknown): item is ImplicitlyTypedValue {
    return reflection.isInstance(item, ImplicitlyTypedValue);
}

export interface Import extends AstNode {
    readonly $container: Model;
    readonly $type: 'Import';
    aliases: Array<ImportAlias>
    target: string
}

export const Import = 'Import';

export function isImport(item: unknown): item is Import {
    return reflection.isInstance(item, Import);
}

export interface ImportAlias extends AstNode {
    readonly $container: Import;
    readonly $type: 'ImportAlias';
    alias: string
    ref: Reference<Package>
}

export const ImportAlias = 'ImportAlias';

export function isImportAlias(item: unknown): item is ImportAlias {
    return reflection.isInstance(item, ImportAlias);
}

export interface InstanceLoop extends AstNode {
    readonly $container: IInstance;
    readonly $type: 'InstanceLoop';
    ivar: InstanceVariable
    ref: Reference<CReference>
    statements: Array<InstanceStatement>
    var: Reference<InstanceVariable>
}

export const InstanceLoop = 'InstanceLoop';

export function isInstanceLoop(item: unknown): item is InstanceLoop {
    return reflection.isInstance(item, InstanceLoop);
}

export interface InstanceVariable extends AstNode {
    readonly $container: FunctionAssignment | FunctionLoop | IFunction | IMacro | InstanceLoop | MacroInstance;
    readonly $type: 'InstanceVariable';
    dtype?: 'tuple' | DataType
    name: string
    type?: Reference<Class>
}

export const InstanceVariable = 'InstanceVariable';

export function isInstanceVariable(item: unknown): item is InstanceVariable {
    return reflection.isInstance(item, InstanceVariable);
}

export interface Interface extends AstNode {
    readonly $container: Package;
    readonly $type: 'Interface';
    abstract: boolean
    body: Array<Statement>
    extendedInterfaces: Array<Reference<Interface>>
    name: string
}

export const Interface = 'Interface';

export function isInterface(item: unknown): item is Interface {
    return reflection.isInstance(item, Interface);
}

export interface MacroAssignStatement extends AstNode {
    readonly $container: MacroInstance;
    readonly $type: 'MacroAssignStatement';
    cref: Reference<CReference>
    instance: Reference<InstanceVariable>
}

export const MacroAssignStatement = 'MacroAssignStatement';

export function isMacroAssignStatement(item: unknown): item is MacroAssignStatement {
    return reflection.isInstance(item, MacroAssignStatement);
}

export interface MacroAttributeStatement extends AstNode {
    readonly $container: MacroInstance;
    readonly $type: 'MacroAttributeStatement';
    attr: Reference<Attribute>
    value: ArithExpr
}

export const MacroAttributeStatement = 'MacroAttributeStatement';

export function isMacroAttributeStatement(item: unknown): item is MacroAttributeStatement {
    return reflection.isInstance(item, MacroAttributeStatement);
}

export interface MacroInstance extends AstNode {
    readonly $container: IMacro;
    readonly $type: 'MacroInstance';
    iVar?: Reference<InstanceVariable>
    nInst?: InstanceVariable
    statements: Array<MacroStatement>
}

export const MacroInstance = 'MacroInstance';

export function isMacroInstance(item: unknown): item is MacroInstance {
    return reflection.isInstance(item, MacroInstance);
}

export interface Model extends AstNode {
    readonly $type: 'Model';
    functions: Array<IFunction>
    imports: Array<Import>
    instances: Array<IInstance>
    macros: Array<IMacro>
    packages: Array<Package>
}

export const Model = 'Model';

export function isModel(item: unknown): item is Model {
    return reflection.isInstance(item, Model);
}

export interface Multiplicity extends AstNode {
    readonly $container: CReference;
    readonly $type: 'Multiplicity';
    mult: MultiplicitySpec
    upperMult?: MultiplicitySpec
}

export const Multiplicity = 'Multiplicity';

export function isMultiplicity(item: unknown): item is Multiplicity {
    return reflection.isInstance(item, Multiplicity);
}

export interface MultiplicitySpec extends AstNode {
    readonly $container: Multiplicity;
    readonly $type: 'MultiplicitySpec';
    n: boolean
    n_0: boolean
    num?: number
}

export const MultiplicitySpec = 'MultiplicitySpec';

export function isMultiplicitySpec(item: unknown): item is MultiplicitySpec {
    return reflection.isInstance(item, MultiplicitySpec);
}

export interface NumberExpr extends AstNode {
    readonly $container: Attribute | BinaryExpression | EnumEntry | FunctionArgument | ImplicitlyTypedValue | MacroAttributeStatement;
    readonly $type: 'NumberExpr';
    value: number
}

export const NumberExpr = 'NumberExpr';

export function isNumberExpr(item: unknown): item is NumberExpr {
    return reflection.isInstance(item, NumberExpr);
}

export interface OppositeAnnotation extends AstNode {
    readonly $container: CReference;
    readonly $type: 'OppositeAnnotation';
    reference: Reference<CReference>
}

export const OppositeAnnotation = 'OppositeAnnotation';

export function isOppositeAnnotation(item: unknown): item is OppositeAnnotation {
    return reflection.isInstance(item, OppositeAnnotation);
}

export interface Package extends AstNode {
    readonly $container: Model | Package;
    readonly $type: 'Package';
    body: Array<AbstractElement>
    name: string
    subPackages: Array<Package>
}

export const Package = 'Package';

export function isPackage(item: unknown): item is Package {
    return reflection.isInstance(item, Package);
}

export interface ReferenceModifiers extends AstNode {
    readonly $container: CReference;
    readonly $type: 'ReferenceModifiers';
    derived: boolean
    ordered: boolean
    readonly: boolean
    resolve: boolean
    transient: boolean
    unique: boolean
    unsettable: boolean
    volatile: boolean
}

export const ReferenceModifiers = 'ReferenceModifiers';

export function isReferenceModifiers(item: unknown): item is ReferenceModifiers {
    return reflection.isInstance(item, ReferenceModifiers);
}

export interface StringExpr extends AstNode {
    readonly $container: Attribute | BinaryExpression | EnumEntry | FunctionArgument | ImplicitlyTypedValue | MacroAttributeStatement;
    readonly $type: 'StringExpr';
    value: string
}

export const StringExpr = 'StringExpr';

export function isStringExpr(item: unknown): item is StringExpr {
    return reflection.isInstance(item, StringExpr);
}

export interface ModelModelingLanguageAstType {
    AbstractElement: AbstractElement
    ArithExpr: ArithExpr
    Attribute: Attribute
    AttributeModifiers: AttributeModifiers
    BinaryExpression: BinaryExpression
    BoolExpr: BoolExpr
    CReference: CReference
    Class: Class
    Enum: Enum
    EnumEntry: EnumEntry
    FunctionArgument: FunctionArgument
    FunctionAssignment: FunctionAssignment
    FunctionCall: FunctionCall
    FunctionLoop: FunctionLoop
    FunctionMacroCall: FunctionMacroCall
    FunctionReturn: FunctionReturn
    FunctionStatement: FunctionStatement
    IFunction: IFunction
    IInstance: IInstance
    IMacro: IMacro
    ImplicitlyTypedValue: ImplicitlyTypedValue
    Import: Import
    ImportAlias: ImportAlias
    InstanceLoop: InstanceLoop
    InstanceStatement: InstanceStatement
    InstanceVariable: InstanceVariable
    Interface: Interface
    MacroAssignStatement: MacroAssignStatement
    MacroAttributeStatement: MacroAttributeStatement
    MacroInstance: MacroInstance
    MacroStatement: MacroStatement
    Model: Model
    Multiplicity: Multiplicity
    MultiplicitySpec: MultiplicitySpec
    NumberExpr: NumberExpr
    OppositeAnnotation: OppositeAnnotation
    Package: Package
    ReferenceModifiers: ReferenceModifiers
    Statement: Statement
    StringExpr: StringExpr
    ValueExpr: ValueExpr
}

export class ModelModelingLanguageAstReflection extends AbstractAstReflection {

    getAllTypes(): string[] {
        return ['AbstractElement', 'ArithExpr', 'Attribute', 'AttributeModifiers', 'BinaryExpression', 'BoolExpr', 'CReference', 'Class', 'Enum', 'EnumEntry', 'FunctionArgument', 'FunctionAssignment', 'FunctionCall', 'FunctionLoop', 'FunctionMacroCall', 'FunctionReturn', 'FunctionStatement', 'IFunction', 'IInstance', 'IMacro', 'ImplicitlyTypedValue', 'Import', 'ImportAlias', 'InstanceLoop', 'InstanceStatement', 'InstanceVariable', 'Interface', 'MacroAssignStatement', 'MacroAttributeStatement', 'MacroInstance', 'MacroStatement', 'Model', 'Multiplicity', 'MultiplicitySpec', 'NumberExpr', 'OppositeAnnotation', 'Package', 'ReferenceModifiers', 'Statement', 'StringExpr', 'ValueExpr'];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case Attribute:
            case CReference: {
                return this.isSubtype(Statement, supertype);
            }
            case BinaryExpression:
            case ValueExpr: {
                return this.isSubtype(ArithExpr, supertype);
            }
            case BoolExpr:
            case NumberExpr:
            case StringExpr: {
                return this.isSubtype(ValueExpr, supertype);
            }
            case Class:
            case Enum:
            case Interface: {
                return this.isSubtype(AbstractElement, supertype);
            }
            case FunctionAssignment:
            case FunctionCall:
            case FunctionMacroCall: {
                return this.isSubtype(FunctionStatement, supertype) || this.isSubtype(InstanceStatement, supertype);
            }
            case FunctionLoop: {
                return this.isSubtype(FunctionStatement, supertype);
            }
            case MacroAssignStatement:
            case MacroAttributeStatement: {
                return this.isSubtype(MacroStatement, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'Class:extendedClasses':
            case 'CReference:type':
            case 'IFunction:type':
            case 'InstanceVariable:type': {
                return Class;
            }
            case 'Class:implementedInterfaces':
            case 'Interface:extendedInterfaces': {
                return Interface;
            }
            case 'FunctionArgument:ref':
            case 'FunctionAssignment:select':
            case 'FunctionReturn:var':
            case 'InstanceLoop:var':
            case 'MacroAssignStatement:instance':
            case 'MacroInstance:iVar': {
                return InstanceVariable;
            }
            case 'FunctionCall:func': {
                return IFunction;
            }
            case 'FunctionMacroCall:macro': {
                return IMacro;
            }
            case 'ImportAlias:ref': {
                return Package;
            }
            case 'InstanceLoop:ref':
            case 'MacroAssignStatement:cref':
            case 'OppositeAnnotation:reference': {
                return CReference;
            }
            case 'MacroAttributeStatement:attr': {
                return Attribute;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case 'AttributeModifiers': {
                return {
                    name: 'AttributeModifiers',
                    mandatory: [
                        { name: 'derived', type: 'boolean' },
                        { name: 'id', type: 'boolean' },
                        { name: 'ordered', type: 'boolean' },
                        { name: 'readonly', type: 'boolean' },
                        { name: 'transient', type: 'boolean' },
                        { name: 'unique', type: 'boolean' },
                        { name: 'unsettable', type: 'boolean' },
                        { name: 'volatile', type: 'boolean' }
                    ]
                };
            }
            case 'BoolExpr': {
                return {
                    name: 'BoolExpr',
                    mandatory: [
                        { name: 'value', type: 'boolean' }
                    ]
                };
            }
            case 'Class': {
                return {
                    name: 'Class',
                    mandatory: [
                        { name: 'abstract', type: 'boolean' },
                        { name: 'body', type: 'array' },
                        { name: 'extendedClasses', type: 'array' },
                        { name: 'implementedInterfaces', type: 'array' }
                    ]
                };
            }
            case 'Enum': {
                return {
                    name: 'Enum',
                    mandatory: [
                        { name: 'entries', type: 'array' }
                    ]
                };
            }
            case 'FunctionCall': {
                return {
                    name: 'FunctionCall',
                    mandatory: [
                        { name: 'args', type: 'array' }
                    ]
                };
            }
            case 'FunctionLoop': {
                return {
                    name: 'FunctionLoop',
                    mandatory: [
                        { name: 'statements', type: 'array' }
                    ]
                };
            }
            case 'FunctionMacroCall': {
                return {
                    name: 'FunctionMacroCall',
                    mandatory: [
                        { name: 'args', type: 'array' }
                    ]
                };
            }
            case 'IFunction': {
                return {
                    name: 'IFunction',
                    mandatory: [
                        { name: 'parameter', type: 'array' },
                        { name: 'returnsVar', type: 'boolean' },
                        { name: 'statements', type: 'array' }
                    ]
                };
            }
            case 'IInstance': {
                return {
                    name: 'IInstance',
                    mandatory: [
                        { name: 'statements', type: 'array' }
                    ]
                };
            }
            case 'IMacro': {
                return {
                    name: 'IMacro',
                    mandatory: [
                        { name: 'instances', type: 'array' },
                        { name: 'parameter', type: 'array' }
                    ]
                };
            }
            case 'Import': {
                return {
                    name: 'Import',
                    mandatory: [
                        { name: 'aliases', type: 'array' }
                    ]
                };
            }
            case 'InstanceLoop': {
                return {
                    name: 'InstanceLoop',
                    mandatory: [
                        { name: 'statements', type: 'array' }
                    ]
                };
            }
            case 'Interface': {
                return {
                    name: 'Interface',
                    mandatory: [
                        { name: 'abstract', type: 'boolean' },
                        { name: 'body', type: 'array' },
                        { name: 'extendedInterfaces', type: 'array' }
                    ]
                };
            }
            case 'MacroInstance': {
                return {
                    name: 'MacroInstance',
                    mandatory: [
                        { name: 'statements', type: 'array' }
                    ]
                };
            }
            case 'Model': {
                return {
                    name: 'Model',
                    mandatory: [
                        { name: 'functions', type: 'array' },
                        { name: 'imports', type: 'array' },
                        { name: 'instances', type: 'array' },
                        { name: 'macros', type: 'array' },
                        { name: 'packages', type: 'array' }
                    ]
                };
            }
            case 'MultiplicitySpec': {
                return {
                    name: 'MultiplicitySpec',
                    mandatory: [
                        { name: 'n', type: 'boolean' },
                        { name: 'n_0', type: 'boolean' }
                    ]
                };
            }
            case 'Package': {
                return {
                    name: 'Package',
                    mandatory: [
                        { name: 'body', type: 'array' },
                        { name: 'subPackages', type: 'array' }
                    ]
                };
            }
            case 'ReferenceModifiers': {
                return {
                    name: 'ReferenceModifiers',
                    mandatory: [
                        { name: 'derived', type: 'boolean' },
                        { name: 'ordered', type: 'boolean' },
                        { name: 'readonly', type: 'boolean' },
                        { name: 'resolve', type: 'boolean' },
                        { name: 'transient', type: 'boolean' },
                        { name: 'unique', type: 'boolean' },
                        { name: 'unsettable', type: 'boolean' },
                        { name: 'volatile', type: 'boolean' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}

export const reflection = new ModelModelingLanguageAstReflection();
